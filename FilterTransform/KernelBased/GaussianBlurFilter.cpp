/**
 * @class GaussianBlurFilter
 * @brief Gaussian Blur Filter kernel implementation.
 */
#include "GaussianBlurFilter.h"

/**
 * @brief Construct a new Gaussian Blur Filter:: Gaussian Blur Filter object
 * 
 * @param size Size/Radius of the kernel matrix.
 * @param parent Passed to AbstractKernelBasedImageFilterTransform() constructor.
 * @param sd Strength of the filter. Which is the standard deviation of the gaussian curve.
 */
GaussianBlurFilter::GaussianBlurFilter(int size, double sd, QObject* parent) : AbstractKernelBasedImageFilterTransform(size, parent)
{
    setKernel(size, sd);
}

/**
 * @brief Gets new image after filter applied.
 * 
 * @param image Original image to get new filter applied image.
 * @param size Size/radius of the kernel.
 * @param strength Strength of the blur.
 * @return QImage Filter applied image.
 */
QImage GaussianBlurFilter::applyFilter(const QImage &image, int size, double strength)
{
    setSize(size);
    setKernel(size, strength);
    return convolution(image);
}

/**
 * @brief This is an overloaded function.
 * 
 * @param image Original image to get new filter applied image.
 * @param size Size/radius of the kernel.
 * @param strength Strength of the blur.
 * @return QImage Filter applied image.
 */
QImage GaussianBlurFilter::applyFilter(const QImage &image, int size)
{
    return applyFilter(image, size, 1.0);
}

/**
 * @brief Returns the name of the filter.
 * 
 * @return QString Name of the filter.
 */
QString GaussianBlurFilter::getName() const
{
    return "Gaussian Blur Filter";
}

/**
 * @brief Construct an gaussian blur kernel with radius size, strength sd.
 *
 * An identity kernel with a dimension ( size * 2 - 1) * ( size * 2 - 1) is constructed.
 * The weight of each entry in the kernel is generated by the gaussian distribution, with center as the mean, and standard deviation sd.
 *
 * @param size Size/radius of the kernel.
 * @param sd Strength/standard deviation of the distribution.
 */
void GaussianBlurFilter::setKernel(int size, double sd)
{
    redefineKernel(size);
    const int MULTIPLIER = 1000;
    for (int dx = -size + 1; dx < size; ++dx)
        for (int dy = -size + 1; dy < size; ++dy) {
            int sqDist = dx * dx + dy * dy; // calculate squared distance to plug in the distribution formula
            double density = 1.0 / qSqrt(2.0 * M_PI * sd * sd) * qExp(-sqDist / 2.0 / sd / sd); // calculate density using gaussian distribution formula
            setEntry(dx, dy, density * MULTIPLIER); // multiply by a large constant to increase precision
    }
}
